let express,bcrypt,User,check,validationResult,jwt,moment;_c9f‍.x([["default",()=>_c9f‍.o]]);_c9f‍.w("express",[["default",["express"],function(v){express=v}]]);_c9f‍.w("bcryptjs",[["default",["bcrypt"],function(v){bcrypt=v}]]);_c9f‍.w("../../db",[["User",["User"],function(v){User=v}]]);_c9f‍.w("express-validator",[["check",["check"],function(v){check=v}],["validationResult",["validationResult"],function(v){validationResult=v}]]);_c9f‍.w("jwt-simple",[["default",["jwt"],function(v){jwt=v}]]);_c9f‍.w("moment",[["default",["moment"],function(v){moment=v}]]);






const router = express.Router();

router.post('/register', [
    check('email', 'Please enter a valid email!').isEmail(),
    check('password', 'Password is required!').not().isEmpty()
], async (req,res)=> {

    const errors = validationResult(req);
    if(!errors.isEmpty()) {
        return res.status(422).json({errors: errors.array()});
    }

    req.body.password = await bcrypt.hash(req.body.password, 10); // 10 times will be encripted
    const user = await User.create(req.body);
    res.json(user);
});

router.post('/login', async (req, res) => {
    const user = await User.findOne({ where: {email: req.body.email} });
    if(user){
        const passwordMatch = await bcrypt.compare(req.body.password, user.password);
        if(passwordMatch){
            res.json({success: createToken(user)});
        } else{
            res.json({error: 'Username or password is invalid!'});
        }
    } else{
        res.json({error: 'Username or password is invalid!'});
    }
});

const createToken = (user) => {
    const payload = {
        userId: user.id,
        createdAt: moment().unix(),
        expiredAt: moment().add(5, 'minutes').unix()
    }
    return jwt.encode(payload, 'ultra secret phrase');
}

_c9f‍.d(router);